--- TTA_Crypto.c.orig	2012-10-23 16:25:21.000000000 +0200
+++ TTA_Crypto.c	2017-03-30 14:39:05.936589767 +0200
@@ -123,7 +123,7 @@
    SLogTrace("TA_CloseSessionEntryPoint");
 
    /* Free the instance data - if not already freed via a call to CmdFreeAllKeysAndOperations */
-   pCryptoData = TEE_GetInstanceData();
+   pCryptoData = (TEE_CryptoData *)TEE_GetInstanceData();
 
    if(pCryptoData != NULL){
       if(pCryptoData->Operation1 != TEE_HANDLE_NULL)
@@ -154,9 +154,9 @@
 TEE_OperationHandle getOperation(uint32_t lopId)
 {
    TEE_CryptoData *pCryptoData;
-   TEE_OperationHandle operation;
+   TEE_OperationHandle operation = TEE_HANDLE_NULL;
    
-   pCryptoData = TEE_GetInstanceData();
+   pCryptoData = (TEE_CryptoData *)TEE_GetInstanceData();
    if(lopId == 1)
       operation = (pCryptoData->Operation1);
    else if(lopId == 2)
@@ -173,7 +173,7 @@
 {
    TEE_CryptoData *pCryptoData;
 
-   pCryptoData = TEE_GetInstanceData();
+   pCryptoData = (TEE_CryptoData *)TEE_GetInstanceData();
 
    return pCryptoData->Attribute;
 }
@@ -182,7 +182,7 @@
 {
    TEE_CryptoData *pCryptoData;
 
-   pCryptoData = TEE_GetInstanceData();
+   pCryptoData = (TEE_CryptoData *)TEE_GetInstanceData();
 
    return pCryptoData->AttributeCount;
 }
@@ -191,7 +191,7 @@
 {
    TEE_CryptoData *pCryptoData;
    
-   pCryptoData = TEE_GetInstanceData();
+   pCryptoData = (TEE_CryptoData *)TEE_GetInstanceData();
 
    if(lopId == 1)
       (pCryptoData->Operation1) = TEE_HANDLE_NULL;
@@ -204,9 +204,9 @@
 TEE_ObjectHandle getKey(uint32_t lkeyId)
 {
    TEE_CryptoData *pCryptoData;
-   TEE_ObjectHandle key;
+   TEE_ObjectHandle key = TEE_HANDLE_NULL;
    
-   pCryptoData = TEE_GetInstanceData();
+   pCryptoData = (TEE_CryptoData *)TEE_GetInstanceData();
    if(lkeyId == 1)
       key = (pCryptoData->Key1);
    else if(lkeyId == 2)
@@ -310,7 +310,7 @@
    nObjectType = pParams[0].value.a;
    nMaxObjectSize = pParams[0].value.b;
    /* Retrieve the pointer to the structure */
-   pCryptoData = TEE_GetInstanceData();
+   pCryptoData = (TEE_CryptoData *)TEE_GetInstanceData();
    
    SLogTrace("CmdInitObjectWithKeys: Before TEE_AllocateTransientObject object1");
    if(pParams[3].value.a == 1)
@@ -371,7 +371,7 @@
    }
    else
    {  
-      pCryptoData = TEE_GetInstanceData();
+      pCryptoData = (TEE_CryptoData *)TEE_GetInstanceData();
       
       if(pCryptoData->Operation1 != TEE_HANDLE_NULL){
          TEE_FreeOperation((pCryptoData->Operation1));
@@ -415,7 +415,7 @@
 {
    /* VARIABLES */
    TEE_CryptoData *pCryptoData;
-   TEE_Result nTempResult;
+   TEE_Result nTempResult = TEE_SUCCESS;
    
    /* CODE */
    if((TEE_PARAM_TYPE_GET(nParamTypes, 0) != TEE_PARAM_TYPE_VALUE_INPUT) &&         /* .a &.b : [in] algorithm & mode */
@@ -430,8 +430,8 @@
       SLogError("CmdAllocateOperation: operation id not correct");
       return TRUSTED_APP_ERROR_BAD_PARAMETERS;
    }
-   
-   pCryptoData = TEE_GetInstanceData();
+
+   pCryptoData = (TEE_CryptoData *)TEE_GetInstanceData();
    if(pParams[3].value.a == 1)
       nTempResult = TEE_AllocateOperation(&pCryptoData->Operation1, pParams[0].value.a, pParams[0].value.b, pParams[1].value.a);
    else if(pParams[3].value.a == 2)
@@ -699,6 +699,83 @@
 }
 
 /**
+ *  Function CmdGetOperationInfoMultiple:
+ *  Description:
+ *    The function is called with:
+ *    - Param#0.a & .b: [in/out] [in].a = operation,
+ *    [out].a = algorithm & [out].b = operationClass
+ *    - Param#1   : [out].a = mode & .b = digestLength
+ *    - Param#2   : [out].a = maxKeySize & .b = handleState
+ *    - Param#3   : [out] = operationState, numberOfKeys,
+ *      KeySize1, requiredKeyUsage1, KeySize2, requiredKeyUsage2
+ */
+TEE_Result CmdGetOperationInfoMultiple(
+   void*       pSessionContext,
+   uint32_t    nParamTypes,
+   TEE_Param   pParams[4])
+{
+   /* VARIABLES */
+   TEE_OperationHandle operation;
+   TEE_OperationInfoMultiple *operationInfoMultiple;
+   TEE_Result res;
+   uint32_t key_num;
+   uint32_t op_size;
+   uint32_t *obuf;
+   uint32_t i;
+   
+   /* CODE */
+   if((TEE_PARAM_TYPE_GET(nParamTypes, 0) != TEE_PARAM_TYPE_VALUE_INOUT) ||
+      (TEE_PARAM_TYPE_GET(nParamTypes, 1) != TEE_PARAM_TYPE_VALUE_OUTPUT) ||
+      (TEE_PARAM_TYPE_GET(nParamTypes, 2) != TEE_PARAM_TYPE_VALUE_OUTPUT) ||
+      (TEE_PARAM_TYPE_GET(nParamTypes, 3) != TEE_PARAM_TYPE_MEMREF_OUTPUT))
+   {
+      SLogError("CmdGetOperationInfo: Bad expected parameter types");
+      return TRUSTED_APP_ERROR_BAD_PARAMETERS;
+   }
+   if((pParams[0].value.a < 1) || (pParams[0].value.a > 4))
+   {
+      SLogError("CmdGetOperationInfo: dest operation id not correct");
+      return TRUSTED_APP_ERROR_BAD_PARAMETERS;
+   }
+   
+   operation = getOperation(pParams[0].value.a);
+   /* key_num computation : buffer size w/o operationState and numberOfKeys */
+   key_num = ((pParams[3].memref.size/4)-2)/2; 
+
+   op_size = sizeof(TEE_OperationInfoMultiple) + key_num * sizeof(TEE_OperationInfoKey);
+   operationInfoMultiple = TEE_Malloc(op_size, 0);
+   if(operationInfoMultiple == NULL)
+      return TRUSTED_APP_ERROR_MALLOC_FAILED;
+
+   res = TEE_GetOperationInfoMultiple(operation, operationInfoMultiple, &op_size);
+   if (res != TEE_SUCCESS)
+	goto out;
+
+   pParams[0].value.a = operationInfoMultiple->algorithm;
+   pParams[0].value.b = operationInfoMultiple->operationClass;
+   pParams[1].value.a = operationInfoMultiple->mode;
+   pParams[1].value.b = operationInfoMultiple->digestLength;
+   pParams[2].value.a = operationInfoMultiple->maxKeySize;
+   pParams[2].value.b = operationInfoMultiple->handleState;
+
+   obuf = (uint32_t *)pParams[3].memref.buffer;
+   *obuf = operationInfoMultiple->operationState;
+   obuf++;
+   *obuf = operationInfoMultiple->numberOfKeys;
+
+   for(i = 0; i < operationInfoMultiple->numberOfKeys; i++) {
+      obuf++;
+      *obuf = operationInfoMultiple->keyInformation[i].keySize;
+      obuf++;
+      *obuf = operationInfoMultiple->keyInformation[i].requiredKeyUsage;
+   }
+   
+out:
+   TEE_Free(operationInfoMultiple);
+   return res;
+}
+
+/**
  *  Function CmdDigestUpdate:
  *  Description:
  *    The function is called with:
@@ -1422,7 +1499,7 @@
    pAttribBufferFromClient = (uint8_t*)pParams[2].memref.buffer;
    
    /* Retrieve the pointer to the structure */
-   pCryptoData = TEE_GetInstanceData();
+   pCryptoData = (TEE_CryptoData *)TEE_GetInstanceData();
 
    /*****************************************************
    *
@@ -1486,7 +1563,7 @@
    TEE_Attribute nAttribute;
    TEE_OperationInfo nOperInfo;
    unsigned char pDerivedKey[128];  /* 1024 bytes */
-   size_t nDerivedKeyLen = sizeof(pDerivedKey);
+   uint32_t nDerivedKeyLen = sizeof(pDerivedKey);
    TEE_Result nTempResult;
 
    /* CODE */
@@ -1570,6 +1647,8 @@
          return CmdSetOperationKey2(pSessionContext, nParamTypes, pParams);
       case CMD_CopyOperation:
          return CmdCopyOperation(pSessionContext, nParamTypes, pParams);
+      case CMD_GetOperationInfoMultiple:
+         return CmdGetOperationInfoMultiple(pSessionContext, nParamTypes, pParams);
       case CMD_GetOperationInfo:
          return CmdGetOperationInfo(pSessionContext, nParamTypes, pParams);
       case CMD_DigestUpdate:
